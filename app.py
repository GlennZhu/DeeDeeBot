"""Streamlit dashboard for macro signal monitoring from cached CSV files."""

from __future__ import annotations

from datetime import datetime, timezone
from pathlib import Path

import pandas as pd
import streamlit as st

from src.config import METRIC_ORDER, SERIES_CONFIG

RAW_DATA_DIR = Path("data/raw")
DERIVED_DATA_DIR = Path("data/derived")

HISTORY_OPTIONS = {
    "5Y": 5,
    "10Y": 10,
    "15Y": 15,
    "All available": None,
}

STATE_COLORS = {
    "long_environment": "#188038",
    "caution_contraction": "#b3261e",
    "recession_alert": "#b3261e",
    "normal": "#1f6feb",
    "equity_pressure_zone": "#b26a00",
    "extreme_pressure_bond_opportunity": "#b3261e",
    "overheat_peak_risk": "#b3261e",
    "labor_weakening": "#b3261e",
    "watch": "#b26a00",
    "stable": "#188038",
    "insufficient_data": "#6b7280",
}


@st.cache_data
def _load_csv(path: Path, date_columns: list[str]) -> pd.DataFrame:
    if not path.exists():
        return pd.DataFrame()
    frame = pd.read_csv(path)
    for col in date_columns:
        if col in frame.columns:
            frame[col] = pd.to_datetime(frame[col], errors="coerce")
    return frame


def _load_metric_series(metric_key: str) -> pd.DataFrame:
    return _load_csv(RAW_DATA_DIR / f"{metric_key}.csv", ["date"])


def _format_value(metric_key: str, value: float) -> str:
    if metric_key in {"hiring_rate", "unemployment_rate", "ten_year_yield"}:
        return f"{value:.2f}%"
    if metric_key == "buffett_ratio":
        return f"{value:.2f}x"
    return f"{value:,.2f}"


def _signal_badge(state: str) -> str:
    color = STATE_COLORS.get(state, "#6b7280")
    return (
        f"<span style='background-color:{color};color:white;padding:0.2rem 0.45rem;"
        "border-radius:0.4rem;font-size:0.78rem;'>"
        f"{state.replace('_', ' ').title()}</span>"
    )


def _apply_history_window(frame: pd.DataFrame, years: int | None) -> pd.DataFrame:
    if frame.empty or years is None or "date" not in frame.columns:
        return frame
    cutoff = pd.Timestamp(datetime.now(timezone.utc).date()) - pd.DateOffset(years=years)
    return frame[frame["date"] >= cutoff]


def _to_m2_yoy(frame: pd.DataFrame) -> pd.DataFrame:
    if frame.empty or "value" not in frame.columns:
        return pd.DataFrame(columns=["date", "value"])
    yoy = frame[["date", "value"]].dropna().sort_values("date").copy()
    yoy["value"] = yoy["value"].pct_change(periods=12) * 100
    return yoy.dropna(subset=["value"])


def _latest_mom_change(frame: pd.DataFrame) -> float | None:
    if frame.empty or "value" not in frame.columns:
        return None
    clean = frame[["date", "value"]].dropna().sort_values("date")
    if len(clean) < 2:
        return None
    return float(clean["value"].iloc[-1] - clean["value"].iloc[-2])


def main() -> None:
    st.set_page_config(page_title="Macro Signal Monitor", layout="wide")
    st.title("Macro Signal Monitor")
    st.caption("Data source: cached CSV generated by GitHub Actions. No live API calls at page load.")

    st.sidebar.header("Controls")
    selected_window = st.sidebar.radio("History Range", list(HISTORY_OPTIONS.keys()), index=2)
    if st.sidebar.button("Refresh Cached Data"):
        st.cache_data.clear()
        st.rerun()

    signals = _load_csv(DERIVED_DATA_DIR / "signals_latest.csv", ["as_of_date", "last_updated_utc"])
    snapshot = _load_csv(DERIVED_DATA_DIR / "metric_snapshot.csv", ["as_of_date", "last_updated_utc"])

    if signals.empty and snapshot.empty:
        st.warning("No cached data found yet. Run `python -m src.pipeline` first.")
        return

    if "last_updated_utc" in snapshot.columns and not snapshot["last_updated_utc"].dropna().empty:
        last_update = snapshot["last_updated_utc"].dropna().max()
        st.info(f"Last successful update (UTC): {last_update}")
    elif "last_updated_utc" in signals.columns and not signals["last_updated_utc"].dropna().empty:
        last_update = signals["last_updated_utc"].dropna().max()
        st.info(f"Last successful update (UTC): {last_update}")

    available_keys = set(snapshot["metric_key"].unique()) if "metric_key" in snapshot.columns else set()
    missing = [key for key in METRIC_ORDER if key not in available_keys]
    if missing:
        st.warning(f"Partial data: missing metrics {', '.join(missing)}")

    series_by_metric = {metric_key: _load_metric_series(metric_key) for metric_key in METRIC_ORDER}

    cols = st.columns(5)
    for idx, metric_key in enumerate(METRIC_ORDER):
        metric_name = SERIES_CONFIG[metric_key]["metric_name"]
        if metric_key == "m2":
            metric_name = "M2 YoY"
        card = cols[idx]
        card.subheader(metric_name)

        metric_snapshot = snapshot[snapshot["metric_key"] == metric_key] if not snapshot.empty else pd.DataFrame()
        metric_signal = signals[signals["metric_key"] == metric_key] if not signals.empty else pd.DataFrame()
        metric_series = series_by_metric.get(metric_key, pd.DataFrame())

        if metric_snapshot.empty and metric_signal.empty:
            card.caption("No data")
            continue

        signal_row = metric_signal.iloc[0] if not metric_signal.empty else None
        snapshot_row = metric_snapshot.iloc[0] if not metric_snapshot.empty else None

        if metric_key == "m2":
            m2_yoy = _to_m2_yoy(metric_series)
            if m2_yoy.empty:
                card.metric("M2 YoY", "N/A")
            else:
                latest_yoy = m2_yoy.iloc[-1]
                card.metric("M2 YoY", f"{float(latest_yoy['value']):.2f}%")
        elif metric_key == "unemployment_rate" and snapshot_row is not None:
            value = float(snapshot_row["value"])
            mom_change = _latest_mom_change(metric_series)
            if mom_change is None:
                card.metric("Value", _format_value(metric_key, value))
            else:
                card.metric(
                    "Value",
                    _format_value(metric_key, value),
                    delta=f"{mom_change:+.2f} pp MoM",
                    delta_color="inverse",
                )
        elif snapshot_row is not None:
            value = float(snapshot_row["value"])
            card.metric("Value", _format_value(metric_key, value))

        if snapshot_row is not None:
            card.caption(f"As of: {pd.Timestamp(snapshot_row['as_of_date']).date().isoformat()}")
            card.caption(f"Stale days: {int(snapshot_row['stale_days'])}")

        if signal_row is not None:
            state = str(signal_row["signal_state"])
            card.markdown(_signal_badge(state), unsafe_allow_html=True)
            if "threshold_rule" in metric_signal.columns and pd.notna(signal_row["threshold_rule"]):
                card.caption(f"Rule: {signal_row['threshold_rule']}")
            if "message" in metric_signal.columns and pd.notna(signal_row["message"]):
                card.caption(f"Interpretation: {signal_row['message']}")
            if "source" in metric_signal.columns and pd.notna(signal_row["source"]):
                card.caption(f"Source: {signal_row['source']}")
        elif snapshot_row is not None and "source" in metric_snapshot.columns and pd.notna(snapshot_row["source"]):
            card.caption(f"Source: {snapshot_row['source']}")

    st.subheader("Historical Series")
    history_years = HISTORY_OPTIONS[selected_window]

    for metric_key in METRIC_ORDER:
        metric_name = SERIES_CONFIG[metric_key]["metric_name"]
        series = series_by_metric.get(metric_key, pd.DataFrame())
        if series.empty:
            continue

        series = _apply_history_window(series, history_years)
        if series.empty:
            continue

        chart_frame = series[["date", "value"]].dropna().sort_values("date")
        if metric_key == "m2":
            metric_name = "M2 YoY (%)"
            chart_frame = _to_m2_yoy(chart_frame)
            if chart_frame.empty:
                continue
        st.markdown(f"**{metric_name}**")
        st.line_chart(chart_frame.set_index("date")["value"])


if __name__ == "__main__":
    main()
